///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2015 The 8-Bit Bunch. Licensed under the Apache License, Version 1.1
// (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-1.1>.
// Unless required by applicable law or agreed to in writing, software distributed under
// the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
// ANY KIND, either express or implied. See the License for the specific language
// governing permissions and limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////

// Functions we import from the main game loop. If you find there are some over there that aren't
// yet exported, modify this header then add the mechanics at the top of gameloop.pla.
include "gamelib.plh"

// Data structure definitions
include "playtype.plh"

// Definition of constants for functions exported by this module
include "party.plh"

// This pointer is the root of all heap-tracked (and garbage collected) objects.
// See playtype.plh for definitions of all the datastructures and how they interconnect.
word global

// Exported functions go here. First a predef for each one, then a table with function pointers
// in the same order as the constants are defined in the the header.
predef _party_doPlayerSheet
word[] funcTbl = @_party_doPlayerSheet

// Other global variables here

///////////////////////////////////////////////////////////////////////////////////////////////////
// Show player data
def showPlayerSheet(num)
  word player, item

  // Count the number of players
  player = global=>p_players
  while num > 0
    player = player=>p_nextObj
    if !player; return; fin // Not that many players
    num--
  loop

  // First, display the player's name in the title bar
  showMapName(player=>s_name)

  // Next, show inventory in the main panel
  setMapWindow()
  clearWindow()
  rawDisplayStr("^Y^LInventory^L^N")
  displayf1("\nGroup Gold: %d", countGold())
  item = player=>p_items
  while item
    displayStr("\n")
    displayStr(item=>s_name)
    item = item=>p_nextObj
  loop

  // Show stats in the right panel
  setWindow2()
  clearWindow()
  rawDisplayStr("^Y^LStats^L^N\n")
  displayf1("%d", player=>w_health);       rawDisplayStr("^T024Health\n")
  displayf1("%d", player->b_intelligence); rawDisplayStr("^T024Intelligence\n")
  displayf1("%d", player->b_strength);     rawDisplayStr("^T024Strength\n")
  displayf1("%d", player->b_agility);      rawDisplayStr("^T024Agility\n")
  displayf1("%d", player->b_stamina);      rawDisplayStr("^T024Stamina\n")
  displayf1("%d", player->b_charisma);     rawDisplayStr("^T024Charisma\n")
  displayf1("%d", player->b_spirit);       rawDisplayStr("^T024Spirit\n")
  displayf1("%d", player->b_luck);         rawDisplayStr("^T024Luck\n")
  displayf1("%d", player->b_armor);        rawDisplayStr("^T024Armor\n")
  
  // Show aquired skills in lower right panel
  setWindow3()
  clearWindow()
  rawDisplayStr("^Y^LSkills^L^N")
  if player->b_aiming;     displayStr("\nAiming");       fin
  if player->b_handToHand; displayStr("\nHand-to-Hand"); fin
  if player->b_dodging;    displayStr("\nDodging");      fin
  return player
end

// Show player sheet and accept command
def _party_doPlayerSheet(num)
  word player
  
  repeat
    player = showPlayerSheet(num)
    if !player; return; fin // Invalid player
    // Get a key, do something
    when getUpperKey()
      // Select another player to show
      is '1'; num = 0; break
      is '2'; num = 1; break
      is '3'; num = 2; break
      // Other operations...
      is '!'; player=>w_health = player=>w_health + 10; break
      // All done
      otherwise return
    wend
  until 0
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Boilerplate module initialization code
global = getGlobals()
return @funcTbl
done
